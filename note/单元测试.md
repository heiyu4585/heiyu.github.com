[TOC]
# 单元测试
## 什么是单元测试

单元测试的目的，就是首先保证一个系统的基本组成单元（类、模块或方法）能正常工作。打个比方，你想一台机器能正常工作，首先要保证它的每一个零件和组件能正常工作。而单元测试就是对这些零件和组件进行的测试。

所谓”测试框架”，就是运行测试的工具。通过它，可以为JavaScript应用添加测试，从而保证代码的质量。

## 为什么要用单元测试

随着项目规模的增加，函数、方法、变量都在递增，尤其是进度的不足，来自产品经理的压力，还有QA所带来的各种Bug报告会让原本整洁的代码变得一片混乱。我甚至见过同一个接口以不同的名称出现在8个不同的控制器中。这时也许我们首先想到的是重构，可是等等，在重构结束时我们如何确定项目仅仅是被重构了，而不是被改写了？此时单元测试将是一根救命稻草，它是一个衡量标准，告诉开发人员这么做是否将改变结果。

参考:
[关于前端开发谈谈单元测试(不错)](https://zhuanlan.zhihu.com/p/19590189)


## 哪些场景需要测试
[聊聊前端开发的测试](https://blog.coding.net/blog/frontend-testing)
## 怎么选择单元测试工具

### 测试管理工具
>测试管理工具是用来组织和运行整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行被测试代码进行测试。测试工具有很多选择，Selenium、WebDriver/Selenium 2、Mocha[1]、JsTestDriver、HTML Runners和Karma，我这里选择使用Karma。（关于它们的对比，可以看看这篇文章：karma 测试框架的前世今生 ）

### 测试框架

>测是框架是单元测试的核心，它提供了单元测试所需的各种API，你可以使用它们来对你的代码进行单元测试。JavaScript的测试框架可谓百花齐放，选择太多了（可以参考List of unit testing frameworks），我这里选择使用Mocha（关于它们中一些框架的对比，可以参考javascript单元测试）

### 断言库
>断言库提供了用于描述你的具体测试的API，有了它们你的测试代码便能简单直接，也更为语义化，理想状态下你甚至可以让非开发人员来撰写单元测试。当然，你也完全可以不使用断言库，而是用自己的测试代码去测试，不过几乎没有人会这么干，除非你自己实现了一个测试断言库。测试断言库的选择也不少：better-assert、should.js、expect.js、chai.js等等（有关它们的对比，可以参考几款前端测试断言库(Assertions lib)的选型总结）我这里选择chai.js。

### 测试浏览器

>前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持调用和运行本地浏览器来进行测试，但如果你的测试仅仅是针对函数和模块的单元测试，则完全可以使用一款无界面的浏览器：PhantomJs

### 测试覆盖率统计工具(一般附带)
>另外，还有一个很重要的事情就是测试覆盖率的统计。一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。


测试管理工具：Karma
测试框架：Mocha
断言库：Chai
测试浏览器：PhantomJs
测试覆盖率统计工具：Karma-Coverage

当前官方的推荐
1. Karma+mocha(vue 官方)
2. jest (react官方),基于jesmine


## 如何选择mocha和 Jasmine?

### Jasmine
>Jasmine是稍微新一点的框架，于qUnit发布后的2年2010年发布。这是一个有足够时间成长的框架，然而仍要学习其他javascript框架。它的初衷是易于安装和适用于任何场景。大多数场景下，它的运行需要Karma或Chutzpah，除了一些发行版本（如jasmine-node npm)有内建的runner。

它的前景如何呢？对于你想要的大多数场景来说，它是非常棒的。异步代码是主要的问题。
### mocha

>Mocha专为nodeJS的模块构建，2012发布重大版本。它的API与Jasmine非常像，多了一些语法糖去适用于更多的场景，如BDD。内建有runner，所以你不用操心runner了。与jasmine不同，它对异步代码的测试有很好的支持，通过调用done函数。如果你的测试使用它，直到done调用了test才能通过。如果没有调用它，当test方法的代码执行完test才能通过。
>虽然是node.js环境，但是它也支持浏览器环境
支持异步的测试用例，包括promise
支持代码覆盖率coverage测试报告
fail的测试用例可以显示differ（暂时只限String）
支持配置进行不同的测试（比如使用什么断言库，显示reporter的方式）
使用任何你喜欢的断言库
多种reporter选择
[官方文档](http://mochajs.org/)
[Mocha.js官方文档翻译 ](http://www.jianshu.com/p/9c78548caffa)
* [mochajs详解](http://www.cnblogs.com/tzyy/p/5729602.html)
* [如何调试 mocha 测试用例](https://blog.coding.net/blog/mocha-test-configuration)
* [javascript单元测试框架mochajs详解](http://www.cnblogs.com/tzyy/p/5729602.html)
* [使用MOCHA前端单元测试](http://hao.jser.com/archive/13187/)
* [mochawesome报告](https://www.npmjs.com/package/mochawesome)
* 
## 如何选择断言库

###Chai
Chai是一个单元测试的验证框架，它有3种不同形式的校验：expect、should和assert。expect和should的方式让写出来的测试代码更像自然语言，让业务人员也可以看懂，而assert方式是传统单元测试断言的方式，如果以前习惯写Java的单元测试会对这种方式比较熟悉。
[Chai.js断言库API中文文档](http://www.jianshu.com/p/f200a75a15d2)
###Sinon
Sinon是一个mock框架，类似Java的mockito。它可以对任何对象进行mock，更重要的是它提供了一些对mock对象的校验方法。
[使用Mocha + Chai + Sinon 测试React + Redux的web应用](http://zhaozhiming.github.io/blog/2015/12/19/use-mocha-and-chai-and-sinon-to-test-react-and-redux-webapp/)

## 其他
### Karma
Karma是由Google团队开发的一套前端测试运行框架。它不同于测试框架（例如jasmine，mocha等），运行在这些测试框架之上。主要完成一下工作：

> Karma启动一个web服务器，生成包含js源代码和js测试脚本的页面
>运行浏览器加载页面，并显示测试的结果
>如果开启检测，则当文件有修改时，执行继续执行以上过程。

参考:[你该使用什么单元测试，Qunit、Jasmine还是Mocha？](https://segmentfault.com/a/1190000006217487)
**推荐阅读:[Javascript单元测试？和大神一起来品尝咖啡吧,推荐 mocha+shold.js+karma](http://hcnode.github.io/2015/07/02/javascript-test/)**  

```
karma是runner, jasmine & mocha 是测试框架, phantomjs就是webkit的实现. 
phantomjs+mocha+chai 
chai是一款断言库 
然后用sinon.js做stub,mock- -
般用, 根据自己需要替换. 一般项目小的时候mocha+should就可以了, 毕竟TJ家
```

## 集成测试环境

* 单测环境 Karma+mocha+chai+Istanbul
*  Karma + Jasmine、Mocha + should、Jest、Enzyme。

目前关于测试，有各式样的代码库供我们选择。他们大多相似，但又不完全一样。要让测试运行起来，通常我们需要选择并配置一个框架（mocha、jasmine）、一个断言代码库（assert、expect、chai、should）、一个或多个运行环境（浏览器、node、node + jsdom）。虽然需要做的事情差不多，但这些事情总归是需要花时间的。如果你希望你的代码同时运行在node和浏览器环境上，你经常要再多花一点时间来考虑让你已有的测试代码在另一个环境上跑起来。

而jest已经集成好了整个环境，你不需要做太多的事情，可以花更多时间在真正的写测试代码上。虽然jest没办法像karma那样直接跑在浏览器上，但至少可以很方便地跑在node的jsdom上。当然集成也就意味着你会失去了一定的灵活性，但在测试这件事情上，大多数时候比较高层次的抽象还是非常合适的。

## 如何选择 cheerio / jsdom
[cheerio中文API](http://www.qdfuns.com/notes/14456/aac353db033f436a3819736358fb6a97.html)
# e2e tests 
## 什么是
## 为什么要用
## 怎么用

参考:
[自动化e2e测试 -- WebDriverJS，Jasmine和Protractor](http://sentsin.com/web/658.html)
---
* [karma+webpack搭建vue单元测试环境](http://www.jianshu.com/p/a515fbbdd1b2)
* [使用 Karma、Mocha、Chai 搭建支持 ES6 的测试环境](http://www.ituring.com.cn/article/264451?utm_source=tuicool&utm_medium=referral)
* [karma+phantomjs+mocha+chai使用心得](http://blog.csdn.net/sliver_ghost/article/details/43404687)

####karma+mocha+webpack+chai 安装过程
```
//karma+mocha+webpack+chai
npm i -D karma chai mocha karma-chrome-launcher karma-webpack karma-html-reporter coverage karma-coverage  karma-mocha karma-chai
```
### 测试时 

注意修改入口文件

关闭公共模块提取

#### 遇到的问题
* 如何输入html格式的报告
 参考:[使用karma-html-reporter配置生成的html测试报告](http://chineseneo.github.io/blog/2013/12/19/shi-yong-karmapei-zhi-javascriptce-shi/)


# 测试react

React测试必须使用官方的测试工具库，但是它用起来不够方便，所以有人做了封装，推出了一些第三方库，其中Airbnb公司的Enzyme最容易上手。

### Jest
Jest 是 Facebook 发布的一个开源的、基于 Jasmine 框架的 JavaScript 单元测试工具。提供了包括内置的测试环境 DOM API 支持、断言库、Mock 库等，还包含了 Spapshot Testing、 Instant Feedback 等特性。

### Enzyme
Airbnb开源的 React 测试类库 Enzyme 提供了一套简洁强大的 API，并通过 jQuery 风格的方式进行DOM 处理，开发体验十分友好。不仅在开源社区有超高人气，同时也获得了React 官方的推荐。

[官方api](http://airbnb.io/enzyme/docs/api/mount.html)

### 框架选择

* [前端单元测试(博客,不错)](http://xwartz.xyz/blog/2016/06/js-unit-testing/)
* [前端自动化测试工具overview](http://imweb.io/topic/56895ae54c44bcc56092e40a)
* [Javascript 单元测试框架有哪些推荐？](https://www.zhihu.com/question/19657421)
* [对 JavaScript 进行单元测试的工具](https://www.ibm.com/developerworks/cn/web/wa-tools/)
* [Node.js 单元测试：我要写测试](http://taobaofed.org/blog/2015/12/10/nodejs-unit-tests/)
* [前端开发自动化单元测试趋势](http://www.jianshu.com/p/ab2ca5b5d909)
* **[前端自动化单元测试初探](http://www.jianshu.com/p/6726c0410650)**
* [JavaScript单元测试入门](http://blog.csdn.net/u012510478/article/details/54728921?utm_source=itdadao&utm_medium=referral)
* [对 JavaScript 进行单元测试的工具(2012年有点早了~)](https://www.ibm.com/developerworks/cn/web/wa-tools/index.html)
* [聊一聊前端自动化测试](https://github.com/tmallfe/tmallfe.github.io/issues/37)
* [关于JavaScript测试工具:QUnit, Jasmine, MoCha](http://www.cnblogs.com/haochuang/p/5714745.html?df=234)

### karma

* [前端自动化测试工具--使用karma进行javascript单元测试](http://blog.csdn.net/future_todo/article/details/52815596)
*  [karma 测试框架的前世今生](http://taobaofed.org/blog/2016/01/08/karma-origin/)
* [karma 测试框架的前世今生](http://taobaofed.org/blog/2016/01/08/karma-origin/)
[前端测试回顾及我们为什么选择Karma](http://www.cnblogs.com/justany/p/4559964.html)
[Karma和Jasmine自动化单元测试](http://blog.fens.me/nodejs-karma-jasmine/)

### jest

* [用jest进一步简化测试](https://blog.oyyd.net/post/what_does_jest_solve)
* [jet官方](http://facebook.github.io/jest/zh-Hans/)


### 学习路径
* **[基于karma+jasmine的web前端自动化测试](http://www.jianshu.com/p/2e5947193793)**
* [Mocha demo](https://github.com/ruanyf/mocha-demos.git)
* [前端单元测试之Karma环境搭建](https://segmentfault.com/a/1190000006895064)

### 配置参考
* [Karma：1. 集成 Karma 和 Jasmine 进行单元测试](http://www.cnblogs.com/haogj/p/5204126.html)
* [Karma：2. 集成 Karma 和 mocha 进行单元测试](http://www.cnblogs.com/haogj/p/5209589.html)
* [Karma 4 - Karma 集成 Webpack 进行单元测试](http://www.cnblogs.com/haogj/p/5209743.html)

[视频](https://www.youtube.com/watch?v=MVw8N3hTfCI)

### enzyme
* [enzyme官方文档](http://airbnb.io/enzyme/)
 *  [mount方法](https://github.com/airbnb/enzyme/blob/master/docs/api/mount.md)
### React
* [React 测试驱动教程(重要)](http://www.jianshu.com/p/6c74c96148c9)
* [ 使用jest+enzyme进行react项目测试 - 测试手法篇](http://echizen.github.io/tech/2017/02-12-jest-enzyme-method)
* [基于 Jest + Enzyme 的 React 单元测试](http://react-china.org/t/jest-enzyme-react/11769)
* [react-redux单元测试(基于react-addons-test-utils,mocha）](http://www.cnblogs.com/dh-dh/p/5432447.html)
* [使用Mocha + Chai + Sinon 测试React + Redux的web应用](https://my.oschina.net/wanjubang/blog/630872?p=1)
* [test-utils](https://facebook.github.io/react/docs/test-utils.html)

* [mocha+ React + enzyme 单元测试](https://my.oschina.net/000quanwei/blog/673599)
* [如何使用 Jest 测试 React 组件](https://www.oschina.net/translate/test-react-components-jest)

### 安装步骤
`npm install --global mocha`

* [React 测试入门教程(阮一峰)](http://www.ruanyifeng.com/blog/2016/02/react-testing-tutorial.html)
* [测试框架 Mocha 实例教程(阮一峰)](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)


# 疑问
* mock测试代码
* e2e测试
* jsdom 11版本就会报Not implemented: navigation的错  node-jsdom y也会报错
* [Babel 入门教程](http://www.ruanyifeng.com/blog/2016/01/babel.html)

---
readme
# 知识点:
[jsdom](https://github.com/tmpvar/jsdom)

# 安装步骤
```
* npm  i -D react-addons-test-utils
```
遇到的坑:
1. Warning: Shallow renderer has been moved to react-test-renderer/shallow. Update references to remove this warning.
    解决方法:
    `npm i -D  react-test-renderer`
2. [mocha测试react+webpack时无法处理alias路径的问题？](https://www.zhihu.com/question/43113948?from=profile_question_card)
3. [jsdom中不包括localStorage](http://top.css88.com/archives/735)
   解决方法:`npm i jsdom中部包括localStorage`
4. [ReactTestUtils has been moved to react-dom/test-utils. Update references to remove this warning.
Warning: Message: React.createClass is deprecated and will be removed in version 16. Use plain JavaScript classes instead. If you're not yet ready to migrate, create-react-class is available on npm as a drop-in replacement.](https://stackoverflow.com/questions/43334942/reacttestutils-has-been-moved)
解决方法:
`npm i --save-dev react-test-renderer `
5.[Warning: Shallow renderer has been moved to react-test-renderer/shallow. Update references to remove this warning.](https://stackoverflow.com/questions/44102857/warning-reacttestutils-has-been-moved-to-react-dom-test-utils-update-reference)
` npm i react-addons-test-utils@15.4.2`
[Shallow renderer has been moved to 参考: react-test-renderer/shallow](https://github.com/airbnb/enzyme/issues/879)

>参考
[Support react-dom/test-utils ](https://github.com/airbnb/enzyme/issues/875)


---
[mocha 测试$.ajax 时报错?](https://segmentfault.com/q/1010000004633301/a-1020000004635699)
[enzyme](http://airbnb.io/enzyme/docs/api/mount.html)

需要测试时,需要把组件拆开测试

需要测试的类型
https://github.com/airbnb/enzyme/blob/master/docs/api/mount.md
```
import { shallow } from 'enzyme';describe('<MyComponent />', () => {
 
  it('should render three <Foo /> components', () => {
    const wrapper = shallow(<MyComponent />);
    expect(wrapper.find(Foo)).to.have.length(3);
  });
 
  it('should render an `.icon-star`', () => {
    const wrapper = shallow(<MyComponent />);
    expect(wrapper.find('.icon-star')).to.have.length(1);
  });
 
  it('should render children when passed in', () => {
    const wrapper = shallow(
      <MyComponent>
        <div className="unique" />
      </MyComponent>
    );
    expect(wrapper.contains(<div className="unique" />)).to.be.true;
  });
 
  it('simulates click events', () => {
    const onButtonClick = sinon.spy();
    const wrapper = shallow(
      <Foo onButtonClick={onButtonClick} />
    );
    wrapper.find('button').simulate('click');
    expect(onButtonClick.calledOnce).to.be.true;
  });});
  
  
  

it('simulates click events', () => { 
  const onButtonClick = sinon.spy()
  const wrapper = shallow(
   <Foo onButtonClick={onButtonClick} />
  )
  wrapper.find('button').simulate('click')
  expect(onButtonClick.calledOnce).to.be.true
})

  
```

>测试组件的交互行为 
我们不但可以通过find方法查找DOM元素，还可以通过simulate方法在组件上模拟触发某个DOM事件，比如Click，Change等等。
对于浅渲染来说，事件模拟并不会像真实环境中所预期的那样进行传播，因此我们必须在一个已经设置好了事件处理方法的实际节点上调用，实际上.simulate()方法将会根据模拟的事件触发这个组件的prop。例如，.simulate('click') 实际上会获取onClick prop并调用它。
Sinon则是一个可以用来Mock和Stub数据代码的第三方测试工具库，当我们需要检查一个组件当中某个特定的函数是否被调用时，我们可以使用sinon.spy()方法监视所传入该组件作为prop的onButtonClick方法，然后再通过wrapper的simulate方法模拟一个Click事件，最终验证这个被spy的onButtonClick函数是否被调用。